"use server"

import { MeetingsService } from "@/lib/meetings"
import { MeetingNotesService } from "@/lib/meeting-notes"
import { createServerSupabase } from "@/lib/supabase-server"
import type { Meeting, MeetingNote, QnAEntry } from "@/lib/types"

// Temporary mock Q&A data until Supabase table exists
const mockQnA: QnAEntry[] = [
  {
    qna_id: 1,
    meeting_id: 1,
    term_or_question: "What is OTIF in supply chain?",
    gpt4_response:
      "OTIF stands for 'On Time In Full'. It's a key performance indicator in supply chain management that measures the percentage of deliveries that are delivered on time and with the complete order quantity. A high OTIF rate indicates efficient supply chain operations.",
  },
  {
    qna_id: 2,
    meeting_id: 2,
    term_or_question: "Explain vendor managed inventory",
    gpt4_response:
      "Vendor Managed Inventory (VMI) is a business model where the supplier takes full responsibility for maintaining the inventory of their products at the buyer's location. The vendor monitors the buyer's inventory levels and makes replenishment decisions. This approach can reduce stockouts, improve cash flow, and strengthen supplier-buyer relationships.",
  },
  {
    qna_id: 3,
    meeting_id: null,
    term_or_question: "What is a bullwhip effect?",
    gpt4_response:
      "The bullwhip effect refers to increasing swings in inventory in response to shifts in consumer demand as one moves further up the supply chain. Small changes in retail demand can result in larger variations in orders placed with wholesalers and manufacturers. This effect can lead to inefficiencies such as excessive inventory, capacity issues, poor customer service, and increased costs throughout the supply chain.",
  },
]

function meetingsService() {
  const supabase = createServerSupabase()
  return new MeetingsService(supabase)
}

function notesService() {
  const supabase = createServerSupabase()
  return new MeetingNotesService(supabase)
}

export async function getRecentMeetings(): Promise<Meeting[]> {
  return meetingsService().getRecent()
}

export async function getMeetings(status: "upcoming" | "past"): Promise<Meeting[]> {
  const svc = meetingsService()
  return status === "upcoming" ? svc.getUpcoming() : svc.getPast()
}

export async function getMeeting(id: number): Promise<Meeting | null> {
  return meetingsService().getById(id)
}

export async function getMeetingNotes(meetingId: number): Promise<MeetingNote | null> {
  return notesService().getByMeetingId(meetingId)
}

export async function saveNotes(meetingId: number, content: string): Promise<MeetingNote> {
  const notes = notesService()
  const existing = await notes.getByMeetingId(meetingId)
  if (existing) {
    return notes.update(existing.note_id, content)
  }
  return notes.create(meetingId, content)
}

export async function getQnAForMeeting(meetingId: number): Promise<QnAEntry[]> {
  // Placeholder until Q&A table is created
  return mockQnA.filter((qna) => qna.meeting_id === meetingId)
}

export async function getAllQnA(): Promise<QnAEntry[]> {
  return mockQnA
}

export async function askQuestion(question: string, meetingId?: number): Promise<QnAEntry> {
  const mockResponse = `This is a simulated response for the question: "${question}". In a real implementation, this would be generated by GPT-4.1 with accurate information about supply chain terminology.`

  const newQnA: QnAEntry = {
    qna_id: mockQnA.length + 1,
    meeting_id: meetingId || null,
    term_or_question: question,
    gpt4_response: mockResponse,
  }

  mockQnA.push(newQnA)
  return newQnA
}

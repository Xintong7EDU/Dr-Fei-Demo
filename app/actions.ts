"use server"

import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
import type { Meeting, MeetingNote, QnAEntry } from '@/lib/types'
import { MeetingNotesService } from '@/lib/meeting-notes'
import { MeetingsService } from '@/lib/meetings'

async function createSupabaseServer() {
  const cookieStore = await cookies()
  
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
      },
    }
  )
}

export async function getMeetings(status: 'upcoming' | 'past'): Promise<Meeting[]> {
  const supabase = await createSupabaseServer()
  const meetingsSvc = new MeetingsService(supabase)
  return meetingsSvc.list(status)
}

export async function getMeeting(id: number): Promise<Meeting | null> {
  const supabase = await createSupabaseServer()
  const meetingsSvc = new MeetingsService(supabase)
  return meetingsSvc.getById(id)
}

export async function createMeeting(
  meeting: Omit<Meeting, 'meeting_id'>
): Promise<Meeting> {
  const supabase = await createSupabaseServer()
  const meetingsSvc = new MeetingsService(supabase)
  return meetingsSvc.create(meeting)
}

export async function updateMeeting(
  id: number,
  updates: Partial<Omit<Meeting, 'meeting_id'>>
): Promise<Meeting> {
  const supabase = await createSupabaseServer()
  const meetingsSvc = new MeetingsService(supabase)
  return meetingsSvc.update(id, updates)
}

export async function getMeetingNotes(meetingId: number): Promise<MeetingNote | null> {
  const supabase = await createSupabaseServer()
  const notesSvc = new MeetingNotesService(supabase)
  return notesSvc.getByMeetingId(meetingId)
}

export async function saveNotes(meetingId: number, content: string): Promise<MeetingNote> {
  const supabase = await createSupabaseServer()
  const notesSvc = new MeetingNotesService(supabase)
  const existing = await notesSvc.getByMeetingId(meetingId)
  if (existing) {
    return notesSvc.update(existing.note_id, content)
  }
  return notesSvc.create(meetingId, content)
}

export async function getQnAForMeeting(meetingId: number): Promise<QnAEntry[]> {
  const supabase = await createSupabaseServer()
  const { data, error } = await supabase
    .from('qna_entries')
    .select('*')
    .eq('meeting_id', meetingId)
    .order('qna_id', { ascending: false })

  if (error) throw error
  return (data ?? []) as QnAEntry[]
}

export async function getAllQnA(): Promise<QnAEntry[]> {
  const supabase = await createSupabaseServer()
  const { data, error } = await supabase
    .from('qna_entries')
    .select('*')
    .order('qna_id', { ascending: false })

  if (error) throw error
  return (data ?? []) as QnAEntry[]
}

export async function askQuestion(question: string, meetingId?: number): Promise<QnAEntry> {
  const supabase = await createSupabaseServer()
  const mockResponse = `This is a simulated response for the question: "${question}". In a real implementation, this would be generated by GPT-4.1 with accurate information about supply chain terminology.`

  const { data, error } = await supabase
    .from('qna_entries')
    .insert({ meeting_id: meetingId ?? null, term_or_question: question, gpt4_response: mockResponse })
    .select()
    .single()

  if (error) throw error
  return data as QnAEntry
}
